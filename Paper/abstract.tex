\begin{abstract}

This paper presents a loop optimization for message passing programs that use affine array accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. The optimization is based on a technique known as modulo unrolling, where the locality of any affine array access can be deduced at compile time if the data is distributed in a cyclic or block cyclic fashion. In this work, modulo unrolling is used to decide when to aggregate messages thereby reducing the overall message count and run time for a particular loop. Compared to other methods, modulo unrolling greatly simplifies the complex problem of automatic code generation of message passing code. It also results in substantial performance improvement compared to the non-optimized Chapel compiler. 

\begin{comment}
This paper presents a loop optimization for message passing programs that use affine array accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. Each message in Chapel incurs some non-trivial run time overhead. Therefore, aggregating messages improves performance. The optimization is based on a technique known as modulo unrolling, where the locality of any affine array access can be deduced at compile time if the data is distributed in a cyclic or block cyclic fashion. First pioneered by Barua \cite{barua1999maps} for tiled architectures, we adapt modulo unrolling to the problem of compiling PGAS languages to message passing architectures. When applied to loops and data distributed cyclically or block cyclically, modulo unrolling can decide when to aggregate messages thereby reducing the overall message count and run time for a particular loop. Compared to other methods, modulo unrolling greatly simplifies the very complex problem of automatic code generation of message passing code from a PGAS language such as Chapel. It also results in substantial performance improvement compared to the non-optimized Chapel compiler.
\end{comment}

To implement this optimization in Chapel, we modify the leader and follower iterators in the Cyclic and Block Cyclic data distribution modules. Results were collected that compare the performance of Chapel programs optimized with modulo unrolling with Chapel programs using the existing Chapel data distributions. Data collected for eleven parallel benchmarks on a ten-locale cluster show that on average, modulo unrolling used with Chapel's Cyclic distribution results in 76 percent fewer messages and a 45 percent decrease in runtime. Similarly, modulo unrolling used with Chapel's Block Cyclic distribution results in 72 percent fewer messages and a 52 percent decrease in runtime for data collected for two parallel benchmarks. 

\end{abstract}

