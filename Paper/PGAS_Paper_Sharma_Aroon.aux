\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}{section.1}}
\newlabel{sec:intro}{{1}{1}{Introduction}{section.1}{}}
\citation{barua1999maps}
\citation{walker1996redistribution}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Chapel's Data Distributions}{2}{subsection.1.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Chapel Block distribution.}}{3}{figure.1}}
\newlabel{block_dist}{{1}{3}{Chapel Block distribution}{figure.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Chapel Block Cyclic distribution with a 2 x 2 blocksize parameter.}}{3}{figure.2}}
\newlabel{block_cyc_dist}{{2}{3}{Chapel Block Cyclic distribution with a 2 x 2 blocksize parameter}{figure.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Chapel Cyclic distribution.}}{3}{figure.3}}
\newlabel{cyc_dist}{{3}{3}{Chapel Cyclic distribution}{figure.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Chapel code for Jacobi computation.}}{3}{figure.4}}
\newlabel{jacobi_code}{{4}{3}{Chapel code for Jacobi computation}{figure.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Motivation for Message Aggregation}{3}{section.2}}
\newlabel{sec:motivation_for_aggregation}{{2}{3}{Motivation for Message Aggregation}{section.2}{}}
\citation{barua1999maps}
\citation{barua1999maps}
\@writefile{toc}{\contentsline {section}{\numberline {3}Modulo Unrolling}{4}{section.3}}
\newlabel{sec:modulo_unrolling}{{3}{4}{Modulo Unrolling}{section.3}{}}
\citation{chamberlain2011user}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Modulo unrolling example. (a) Original sequential for loop. Array $A$ is distributed using a Cyclic distribution. Each array access maps to a different memory bank on successive loop iterations. (b) Fully unrolled loop. Trivially, each array access maps to a single memory bank because each access only occurs once. This loop dramatically increases the code size for loops traversing through large data sets. (c) Loop transformed using modulo unrolling. The loop is unrolled by a factor equal to the number of memory banks on the architecture. Now each array access is guaranteed to map to a single memory bank for all loop iterations and code size increases only by the loop unroll factor.}}{5}{figure.5}}
\newlabel{modulo_unrolling}{{5}{5}{Modulo unrolling example. (a) Original sequential for loop. Array $A$ is distributed using a Cyclic distribution. Each array access maps to a different memory bank on successive loop iterations. (b) Fully unrolled loop. Trivially, each array access maps to a single memory bank because each access only occurs once. This loop dramatically increases the code size for loops traversing through large data sets. (c) Loop transformed using modulo unrolling. The loop is unrolled by a factor equal to the number of memory banks on the architecture. Now each array access is guaranteed to map to a single memory bank for all loop iterations and code size increases only by the loop unroll factor}{figure.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Chapel Zippered Iteration}{5}{section.4}}
\newlabel{sec:zippered_iteration}{{4}{5}{Chapel Zippered Iteration}{section.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Chapel Array Slicing}{5}{subsection.4.1}}
\newlabel{sec:array_slicing}{{4.1}{5}{Chapel Array Slicing}{subsection.4.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Cyclic Distribution with Modulo Unrolling}{6}{section.5}}
\newlabel{sec:cyclic_modulo}{{5}{6}{Cyclic Distribution with Modulo Unrolling}{section.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces (a) Chapel code fragment showing a loop using zippered iteration. A tuple of loop index variables equal to the number of items in the zippering is declared in the loop header. If the variable $j$ corresponds to the current loop iteration, $i$ corresponds to the $j^{th}$ element in the range $1..5$, and $f$ corresponds to the $j^{th}$ element in the iterator $fibonacci(5)$. The \textit  {zip} keyword tells the loop header which items to iterate over using zippered iteration. (b) Program output of the code fragment in Figure\nobreakspace  {}\ref  {zippered_iteration}a.}}{6}{figure.6}}
\newlabel{zippered_iteration}{{6}{6}{(a) Chapel code fragment showing a loop using zippered iteration. A tuple of loop index variables equal to the number of items in the zippering is declared in the loop header. If the variable $j$ corresponds to the current loop iteration, $i$ corresponds to the $j^{th}$ element in the range $1..5$, and $f$ corresponds to the $j^{th}$ element in the iterator $fibonacci(5)$. The \textit {zip} keyword tells the loop header which items to iterate over using zippered iteration. (b) Program output of the code fragment in Figure~\ref {zippered_iteration}a}{figure.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces (a) Original loop written using a single loop induction variable $i$ ranging from 1 to 10. (b) The same loop written using zippered iteration. Instead of a loop induction variable and a range of values to denote the loop bounds, two array slices containing 10 elements each are specified.}}{6}{figure.7}}
\newlabel{affine_loop}{{7}{6}{(a) Original loop written using a single loop induction variable $i$ ranging from 1 to 10. (b) The same loop written using zippered iteration. Instead of a loop induction variable and a range of values to denote the loop bounds, two array slices containing 10 elements each are specified}{figure.7}{}}
\citation{callahan1988compiling}
\citation{chamberlain1998zpl}
\citation{chamberlain1997factor}
\citation{chavarria2005effective}
\citation{davidson1995improving}
\citation{Dion96compilingaffine}
\citation{germain1995automatic}
\citation{Gupta91automaticdata}
\citation{gupta1996compiling}
\citation{huang1994speculative}
\citation{iancu2008performance}
\citation{li1991data}
\citation{pouchet2011loop}
\citation{ramanujam1991compile}
\citation{shih2000efficient}
\citation{trifunovic2010graphite}
\citation{wei1998compiling}
\citation{chamberlain2011user}
\citation{bonachea2007proposal}
\citation{sanz2012global}
\@writefile{toc}{\contentsline {section}{\numberline {6}Block Cyclic Distribution with Modulo Unrolling}{7}{section.6}}
\newlabel{sec:block_cyclic_modulo}{{6}{7}{Block Cyclic Distribution with Modulo Unrolling}{section.6}{}}
\@writefile{toc}{\contentsline {section}{\numberline {7}Results}{7}{section.7}}
\newlabel{sec:results}{{7}{7}{Results}{section.7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Benchmark suite.}}{7}{figure.8}}
\newlabel{benchmarks}{{8}{7}{Benchmark suite}{figure.8}{}}
\@writefile{toc}{\contentsline {section}{\numberline {8}Related Work}{7}{section.8}}
\newlabel{sec:relwork}{{8}{7}{Related Work}{section.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Cyclic runtime.}}{8}{figure.9}}
\newlabel{cyclic_runtime}{{9}{8}{Cyclic runtime}{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Cyclic message count.}}{8}{figure.10}}
\newlabel{cyclic_message_count}{{10}{8}{Cyclic message count}{figure.10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Block Cyclic runtime.}}{8}{figure.11}}
\newlabel{block_cyclic_runtime}{{11}{8}{Block Cyclic runtime}{figure.11}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Block Cyclic message count.}}{8}{figure.12}}
\newlabel{block_cyclic_message_count}{{12}{8}{Block Cyclic message count}{figure.12}{}}
\bibdata{bibliography}
\bibcite{barua1999maps}{1}
\bibcite{bonachea2007proposal}{2}
\bibcite{callahan1988compiling}{3}
\bibcite{chamberlain2011user}{4}
\bibcite{chamberlain1997factor}{5}
\bibcite{chamberlain1998zpl}{6}
\bibcite{chavarria2005effective}{7}
\bibcite{davidson1995improving}{8}
\bibcite{Dion96compilingaffine}{9}
\bibcite{germain1995automatic}{10}
\bibcite{Gupta91automaticdata}{11}
\bibcite{gupta1996compiling}{12}
\bibcite{huang1994speculative}{13}
\bibcite{iancu2008performance}{14}
\bibcite{li1991data}{15}
\bibcite{pouchet2011loop}{16}
\bibcite{ramanujam1991compile}{17}
\bibcite{sanz2012global}{18}
\bibcite{shih2000efficient}{19}
\bibcite{trifunovic2010graphite}{20}
\bibcite{walker1996redistribution}{21}
\bibcite{wei1998compiling}{22}
\bibstyle{abbrv}
