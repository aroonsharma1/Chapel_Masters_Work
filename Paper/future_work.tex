\section{Future Work}\label{sec:future_work}

As presented, the modulo unrolling WU optimization can be improved upon in a few ways to achieve even better performance in practice. First, there is currently no limit on the number of array elements that an aggregate message may contain. For applications with extremely large data sets, buffers containing remote data elements may become too large and exceed the memory budget of a particular locale. This may slow down other programs running on the system. A naive solution to this problem is to just turn off the optimization when the aggregate message is deemed too large and communicate remote data elements individually. A better solution would be to perform strip mining where the aggregate message is broken down into smaller aggregate messages of a configurable threshold size. 

The two forms of bulk communication used in this work (\texttt{chpl\_comm\_gets} and \texttt{chpl\_comm\_puts}) are both blocking communication calls. Our optimization might achieve better performance if it used a non-blocking strided bulk communication scheme. That way, communication and computation may be able to occur in parallel. 

Finally, it would be extremely beneficial if our implementation of modulo unrolling WU in the Cyclic follower iterator did not slow down programs with few data elements per chunk of parallel work. Ideally, these programs should, in the worst case, run as fast as they would if the original Chapel Cyclic follower iterator was used. Our research group is currently working on adding a dynamic check within the follower iterator that tests whether the number of data elements per chunk of parallel work is above the threshold where aggregation is still profitable. If not, the original follower iterator without modulo unrolling WU is called. 

