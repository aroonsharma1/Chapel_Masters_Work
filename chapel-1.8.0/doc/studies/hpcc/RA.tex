\section{Random Access}
The Random Access benchmark reports the measurement, Giga Updates Per Second (GUPS),  
for randomly accessing and updating elements of a large array.  The size of 
this large array is the largest power of 2 that is less than or equal to the
size of system memory.  Each element of the array is to be updated four times, and the 
array updates are to be done in a random order as generated by the primitive polynomial
over GF(2), $X^{63} + X^2 + X + 1$.  

\subsection{The Update Loop}

\subsubsection{Single processor reference implementation}
\begin{C}
static void
RandomAccessUpdate(unsigned long long TableSize, unsigned long long *Table) {
  long long i;
  unsigned long long ran[128];              
  int j;

  for (i=0; i<TableSize; i++) Table[i] = i;

  for (j=0; j<128; j++) {
    ran[j] = HPCC_starts ((NUPDATE/128) * j);
  }

  for (i=0; i<NUPDATE/128; i++) {
    for (j=0; j<128; j++) {
      ran[j] = (ran[j] << 1) ^ ((long long) ran[j] < 0 ? POLY : 0);
      Table[ran[j] & (TableSize-1)] ^= ran[j];
    }
  }
}
\end{C}

\subsubsection{C + MPI}
See Appendix~\ref{randmpi}.

\subsubsection{UPC}
\begin{C}
#pragma _CRI concurrent
for (j=0; j<STRIPSIZE; j++) {
  for (i=0; i<SendCnt/STRIPSIZE; i++) {
    VRan[j] = (VRan[j] << 1) ^ ((s64Int)VRan[j]
               < ZERO64B ? POLY : ZERO64B);
    GlobalOffset = VRan[j] & (TableSize - 1);
    if (PowerofTwo)
      LocalOffset=GlobalOffset>>logNumProcs ;
    else
      LocalOffset=(double)GlobalOffset/(double)THREADS;
    WhichPe=GlobalOffset-LocalOffset*THREADS;
    Table[LocalOffset][WhichPe] ^= VRan[j] ;
  }
}
\end{C}

\subsubsection{Serial Chapel}
\begin{chapel}
const NumUpdates:uint(64) = 4*TableSize;
const NumStreams:int = STREAMPARAM;
const BigStep:int = (NumUpdates:int)/NumStreams;
const TableDomain = [0..(TableSize-1):int];
var Table: [TableDomain] uint(64);

def RandomAccessUpdate() {

  [i in TableDomain] Table(i) = i:uint(64);

  for j in StreamDomain {
    var ran:uint(64) = RandomStart(BigStep*j);
    for i in BigStepDomain {
      ran = (ran << 1) ^ (if (ran:int(64) < 0) then POLY else 0);
      Table((ran & (TableSize-1)):int) ^= ran;
    }
  }
}
\end{chapel}

\subsection{Distribution of Table array}
\subsubsection{The Cray MTA-2 system}
Flat shared memory - no distribution.
\subsubsection{A Linux cluster system}
Mention how non-powers of 2 numbers of processors are handled.  Underlying
MPI version can't store more than 1024 lookahead updates.

\subsection{Parallel Chapel version of update loop}

\subsubsection{Parallel outer loop implementation}

\begin{chapel}
const NumUpdates:uint(64) = 4*TableSize;
const NumStreams:int = STREAMPARAM;
const BigStep:int = (NumUpdates:int)/NumStreams;

const TableDomain: domain(1,blockcyclic(1)) = [0..(TableSize-1):int];
var Table: [TableDomain] uint(64);

const StreamDomain = [0..NumStreams-1];
const BigStepDomain = [0..BigStep-1];

def RandomAccessUpdate() {

  [i in TableDomain] Table(i) = i:uint(64);

  forall j in StreamDomain {
    var ran:uint(64) = RandomStart(BigStep*j);
    for i in BigStepDomain {
      ran = (ran << 1) ^ (if (ran:int(64) < 0) then POLY else 0);
      Table((ran & (TableSize-1)):int) ^= ran;
    }
  }
}
\end{chapel}

\subsubsection{Adding an inner vector loop}

\begin{chapel}
const VectorLength:int = VLPARAM;
const NumStreams:int = STREAMPARAM;

const NumUpdates:uint(64) = 4*TableSize;
const BigStep:int = (NumUpdates:int)/NumStreams;
const TableDomain: domain(1,blockcyclic(1)) = [0..(TableSize-1):int];
var Table: [TableDomain] uint(64);

const VectorDomain = [0..VectorLength-1];
const StreamDomain = [0..NumStreams-1];
const BigStepDomain = [0..BigStep-1];

def RandomAccessUpdate() {

  [i in TableDomain] Table(i) = i:uint(64);

  forall j in StreamDomain {
    var ranvec: [VectorDomain] uint(64);
    [k in VectorDomain] ranvec(k) = RandomStart(BigStep*j+(BigStep/VectorLength)*k);
    for i in BigStepDomain by VectorLength{
      forall k in VectorDomain{
        ranvec(k) = (ranvec(k) << 1) ^ (if (ranvec(k):int(64) < 0) then POLY else 0);
        Table((ranvec(k) & (TableSize-1)):int) ^= ranvec(k);
      }
    }
  }
}
\end{chapel}

\subsubsection{Compiler handled details}
What about atomic updates?  How will we handle those?



