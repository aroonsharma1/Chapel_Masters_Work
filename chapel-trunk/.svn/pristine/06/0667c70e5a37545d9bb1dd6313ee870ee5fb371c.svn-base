Steps to committing code
------------------------

The following are our current steps for contributing code to Chapel.
These are expected to evolve over time as the governance of Chapel is
migrated from Cray to an external/community body (the major elements
are likely to be similar, though the specific people involved are
likely to change and grow).


* If you're working on a long-term effort, announce it on the
  chapel-developers mailing list at SourceForge to make sure toes are
  not being stepped on, work is not being pursued redundantly, etc.
  Similarly, fundamental changes to the language or architecture
  should be circulated to the chapel-developers and/or chapel-users
  lists to make sure effort is not wasted.


* If your work will require committing any third-party code that you
  are not developing yourself (or code that you've developed as a
  standalone package), alert the chapel-developers mailing list of
  this as, presently, such code packages must be approved by Cray
  leadership before being committed.


* Sign a Chapel contributor's agreement, located at the URL below, and
  send it to your contact at Cray (ask for one at the SourceForge
  chapel-developers list if you don't).

    http://svn.code.sf.net/p/chapel/code/trunk/doc/developer/contributorAgreements/


* Develop your patch.


* In order for a patch to be committed to the source tree, it should
  (a) pass testing and (b) be reviewed by a member of the core Chapel
  team (currently, a member of the Cray Chapel team).  At that point,
  it can either be committed directly by you; or it can be committed
  by someone else on the Chapel team who has commit permissions on
  your behalf.


* Testing your patch:

  - any addition/change to the Chapel test system should pass testing
    when that test/directory is run with start_test (and performance
    tests should also pass testing for 'start_test -performance').

  - changes to the Chapel implementation should not cause regressions.
    Developers are responsible for doing a degree of testing that's
    appropriate for their change (see guidance below) and then can
    rely on nightly regression testing to worry about the full
    cross-product of configurations.

    - at a minimum, patches should pass correctness testing for the
      full test/ directory hierarchy for:

      - CHPL_*_PLATFORM=linux64
      - CHPL_*_COMPILER=gnu
      - CHPL_COMM=none
      - CHPL_TASKS=<default>

      Most developers will start by focusing on a subdirectory of
      tests that exercise the features they changed, or test/release/
      as a test that exercises a rich and important slice of the
      language.

    - changes that are likely to affect multi-locale executions should
      also be tested against tests that exercise multi-locale
      capabilities with CHPL_COMM=gasnet.  A common subset is:
      test/release/, test/multilocale/, and test/distributions/

    - changes that are likely to cause portability issues should be
      tested against different platforms and compilers to avoid
      fallout in the nightly testing to the extent possible.

  - note that the quickest way to do testing is to use the parallel
    testing system across a large number of workstations.  If you have
    limited testing resources available to you, you can request that a
    member of the core Chapel team help with 


* When you believe your patch is ready for review, send it to a member
  of the core Chapel team (or chapel-developers if there isn't an
  obvious person to review it) with:

  - '[patch] <description>' as the subject line, where "<description>"
    is a brief description of your change.  For example:

       Subject: [patch] optimize remote accesses

  - the patch itself as an attachment.  Patches are most often
    created by using 'svn diff' against the current trunk.

  - a proposed commit message describing the patch, either in the body
    of the message or as an attachment.

  Ideally, someone should volunteer to review your patch within a day
  or two.  If this doesn't happen, feel free to make some noise.
  Ideally the review should take place within a few days, though
  timing may vary depending on other deadlines.


* Iterate with the reviewer until you're both satisfied.  If you can't
  come to agreement, one of you should bring other developers
  (individually or via chapel-developers) into the conversation to get
  a broader opinion (one of the jobs of the reviewer is to serve as a
  proxy for other developers, or to bring those developers into the
  conversation if they don't feel like they can).


* Once the patch has been approved for commit, determine who will
  commit it.  If it's you, request commit privileges from whoever
  accepted your contributor agreement (making sure to tell them your
  SourceForge account name).


* Recall that commits to subversion are extremely difficult to remove
  from the source tree's history, so be very careful not to commit
  anything that you might regret later (e.g., sensitive code, code
  owned by anyone other than yourself).  Ideally, the review will
  catch such issues, but the ultimate responsibility is on the
  developer.


* Commit your code.


* In short order, a smoke-test will be run against the commit to make
  sure that nothing basic has been broken by it.  Monitor the
  chapel-test-results-regressions mailing list to make sure that
  nothing breaks.


* For the day or two after the commit has gone in, check the
  chapel-test-results-regressions mailing list to ensure that there
  are no new failures (or that they are due to a commit other than
  yours).  Use the chapel-developers mailing list if you are unsure (a
  member of the core Chapel team will be tasked with diagnosing any
  testing failures on any given night, but it's nice when developers
  notice the issue first themselves to save wasted effort).


* Experienced developers may make minor fixes to code or
  documentation, or add new tests, without review, but the changes
  should generally be quite minor and innocuous in scope.  When in
  doubt, err on the side of getting a review.
